import pdfplumber
from edx_graph_renderer import render_modified_GENESIS
import struct
import os


def extract_from_EDAX_pdf(file_path):
    # This script is intended to take a directory or tree of directories of PDFs generated by EDAX GENESIS
    # And extract data from them to re-plot in a nicer format

    with pdfplumber.open(file_path) as pdf:

        # Get the full-scale value (maximum value of the graph)
        pdf_text = pdf.pages[0].extract_text_simple()
        fs_index = pdf_text.find('FS')  # "FS" meaning full scale value
        fs_colon_index = pdf_text.find(':', fs_index)
        fs_end_index = pdf_text.find('L', fs_index)  # The next text is "Lsec"
        full_scale_value = float(pdf_text[fs_colon_index+1:fs_end_index])

        # Instead of detecting the limits of the graph, use the limits of the box that it's in
        # Will need to either detect the horizontal limits of that box, or observe them and hardcode it in
        # Can use the bounding box function to remove everything that isn't in the box
        # The horizontal bounds of the box are the same as the maximum horizontal bounds of any edge in the PDF
        all_lower_edges = [(l['x0'], l['y0'], l['x1'], l['y1'], l['stroking_color']) for l in pdf.pages[0].edges if l['y1'] < 400]

    # Now find the actual lines that are associated with the graph
    graph_lines = [l for l in all_lower_edges if l[4] == (1.0, 0.0, 0.0)]

    line_bounds = (min(all_lower_edges, key=lambda l: l[0])[0], min(graph_lines, key=lambda l: l[1])[1], max(all_lower_edges, key=lambda l: l[2])[2], max(graph_lines, key=lambda l: l[3])[3])  # min x, min y, max x, max y
    graph_data = []
    for line in graph_lines:
        nondim_x = (line[0] - line_bounds[0]) / (line_bounds[2] - line_bounds[0])
        keV_val = 10 * nondim_x
        nondim_y = (line[3] - line_bounds[1]) / (line_bounds[3] - line_bounds[1])
        scale_val = full_scale_value * nondim_y
        graph_data.append((keV_val, scale_val))
        # plt.plot((line[0], line[2]), (line[1], line[3]), linewidth=3)
    # graph_data.sort(key=lambda x: x[0])
    graph_data.insert(0, (graph_data[0][0], 0.0))
    graph_data.insert(0, (0.0, 0.0))

    return graph_data


def extract_from_spc(file_path):
    # This file is designed to extract the spectral data from the SPC files that Dr. Merchan is giving me
    # I believe that these files are generated from a program called GENESIS by the company EDAX
    # But no SPC file viewer I've tried (SpectraGryph1.2, SpectralWorks' ScanEdit) seems to be able to read these
    # And it seems to be very difficult to get a working copy of GENESIS

    # The first SPC file I have appears to have four-byte integer data starting at address 0x00000F2C (integer 3884)
    # This appears to be true for every SPC file that I've seen
    # 4-byte (32-bit) unsigned (?) integers = longs (or ints on some platforms)

    graph_data_start = 3840  # right now, data seems to start at 3884, but that might not be 0 keV
    # For some graphs, there appear to be 11 more datapoints before the first keV that the detector can actually read
    # According to an associated CSV document that was presumably generated by the program at the same time
    # So the beginning of the graph is at 3840

    with open(file_path, 'rb') as file:
        file_data = file.read()

    # Between two ticks on the x-axis of the graph (ex between 8.00 and 9.00 keV) there are 100 bars
    # --> Between 0.00 and 10.0 there are about 1000 bars
    # --> 4000 bytes total
    num_bars = 1000
    graph_data_bytes = file_data[graph_data_start:graph_data_start + (4 * num_bars)]

    dependent_data = [struct.unpack('<l', graph_data_bytes[i * 4:(i * 4 + 4)])[0] for i in range(num_bars)]

    independent_axis = [10 * i / num_bars for i in range(num_bars)]

    graph_data = list(zip(independent_axis, dependent_data))
    return graph_data


def extract_from_csv(file_path):
    # Plot the data from CSV plots that accompany some of the PDF and SPC files, for comparison
    with open(file_path, 'r') as file:
        lines = file.readlines()

        csv_data = [(float(l.split(",")[0]), float(l.split(",")[1])) for l in lines[:1000]]

        csv_data_x_bounds = (min(csv_data, key=lambda p: p[0])[0], max(csv_data, key=lambda p: p[0])[0])

        # Need to rescale independent data to be between 0 and 10 KeV
        graph_data = []
        for i in range(len(csv_data)):
            graph_data.append((10.0 * csv_data[i][0] / csv_data_x_bounds[1], csv_data[i][1]))
            # I happen to know that the csv x data starts at 0, so I can make this simpler

    return graph_data


if __name__ == "__main__":
    # Run the appropriate data extraction on every sample point according to which files are available
    # This expects that the data is structured like this:
    #   Full Data Directory
    #       Location 1 Directory
    #           Point 1 Directory
    #               File 1
    #               File 2
    #               ...
    #           Point 2 Directory
    #               File 1
    #               ...
    #           ...
    #       Location 2 Directory
    #           ...
    full_data_dir = "Ecuador EDX Data"
    new_full_data_dir = full_data_dir + " Images"
    assert not os.path.isdir(new_full_data_dir)
    os.mkdir(new_full_data_dir)
    for loc_dir in os.listdir(full_data_dir):
        os.mkdir(os.path.join(new_full_data_dir, loc_dir))
        for point_dir in os.listdir(os.path.join(full_data_dir, loc_dir)):
            os.mkdir(os.path.join(new_full_data_dir, loc_dir, point_dir))
            point_files = os.listdir(os.path.join(full_data_dir, loc_dir, point_dir))
            extensions = [filename[-4:].lower() for filename in point_files]
            # Hierarchy of data: CSV is preferred, then SPC, then PDF
            if ".csv" in extensions:
                # CSV does exist; use that
                filename = point_files[extensions.index(".csv")]
                graph_data = extract_from_csv(os.path.join(full_data_dir, loc_dir, point_dir, filename))
            elif ".spc" in extensions:
                # SPC does exist; use that
                filename = point_files[extensions.index(".spc")]
                graph_data = extract_from_spc(os.path.join(full_data_dir, loc_dir, point_dir, filename))
            elif ".pdf" in extensions:
                # PDF does exist; use that
                filename = point_files[extensions.index(".pdf")]
                graph_data = extract_from_EDAX_pdf(os.path.join(full_data_dir, loc_dir, point_dir, filename))
            else:
                # No usable files
                print(f"No usable files found for point {point_dir}!")
                continue

            render_modified_GENESIS([(0, 0), (10, 0)], graph_data, save_to=os.path.join(new_full_data_dir, loc_dir, point_dir, filename[:-4] + ".png"), show=False)
